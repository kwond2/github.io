\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    \usepackage{cancel}


\usepackage{amsmath,amsfonts,amsthm,amssymb}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}
    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    \usepackage{algpseudocode} % for main algo stuff
    \usepackage{algorithm} % to label the algo
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for grffile with XeLaTeX
    \def\Gread@@xetex#1{%
      \IfFileExists{"\Gin@base".bb}%
      {\Gread@eps{\Gin@base.bb}}%
      {\Gread@@xetex@aux#1}%
    }
    \makeatother

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}

%% macros for editing and commenting
\usepackage[normalem]{ulem} % to use \sout
\newcommand{\remove}[1]{{\color{Gray}\sout{#1}}}
\newcommand{\revise}[1]{{\color{blue}#1}}
\newcommand{\comm}[1]{{\color{red}(yx: #1)}}

\newcommand{\bm}[1]{\boldsymbol{#1}}


%% macros for vectors
\newcommand{\va}{{\mathbf{a}}}
\newcommand{\vb}{{\mathbf{b}}}
\newcommand{\vc}{{\mathbf{c}}}
\newcommand{\vd}{{\mathbf{d}}}
\newcommand{\ve}{{\mathbf{e}}}
\newcommand{\vf}{{\mathbf{f}}}
\newcommand{\vg}{{\mathbf{g}}}
\newcommand{\vh}{{\mathbf{h}}}
\newcommand{\vi}{{\mathbf{i}}}
\newcommand{\vj}{{\mathbf{j}}}
\newcommand{\vk}{{\mathbf{k}}}
\newcommand{\vl}{{\mathbf{l}}}
\newcommand{\vm}{{\mathbf{m}}}
\newcommand{\vn}{{\mathbf{n}}}
\newcommand{\vo}{{\mathbf{o}}}
\newcommand{\vp}{{\mathbf{p}}}
\newcommand{\vq}{{\mathbf{q}}}
\newcommand{\vr}{{\mathbf{r}}}
\newcommand{\vs}{{\mathbf{s}}}
\newcommand{\vt}{{\mathbf{t}}}
\newcommand{\vu}{{\mathbf{u}}}
\newcommand{\vv}{{\mathbf{v}}}
\newcommand{\vw}{{\mathbf{w}}}
\newcommand{\vx}{{\mathbf{x}}}
\newcommand{\vy}{{\mathbf{y}}}
\newcommand{\vz}{{\mathbf{z}}}

%% macros for matrices
\newcommand{\vA}{{\mathbf{A}}}
\newcommand{\vB}{{\mathbf{B}}}
\newcommand{\vC}{{\mathbf{C}}}
\newcommand{\vD}{{\mathbf{D}}}
\newcommand{\vE}{{\mathbf{E}}}
\newcommand{\vF}{{\mathbf{F}}}
\newcommand{\vG}{{\mathbf{G}}}
\newcommand{\vH}{{\mathbf{H}}}
\newcommand{\vI}{{\mathbf{I}}}
\newcommand{\vJ}{{\mathbf{J}}}
\newcommand{\vK}{{\mathbf{K}}}
\newcommand{\vL}{{\mathbf{L}}}
\newcommand{\vM}{{\mathbf{M}}}
\newcommand{\vN}{{\mathbf{N}}}
\newcommand{\vO}{{\mathbf{O}}}
\newcommand{\vP}{{\mathbf{P}}}
\newcommand{\vQ}{{\mathbf{Q}}}
\newcommand{\vR}{{\mathbf{R}}}
\newcommand{\vS}{{\mathbf{S}}}
\newcommand{\vT}{{\mathbf{T}}}
\newcommand{\vU}{{\mathbf{U}}}
\newcommand{\vV}{{\mathbf{V}}}
\newcommand{\vW}{{\mathbf{W}}}
\newcommand{\vX}{{\mathbf{X}}}
\newcommand{\vY}{{\mathbf{Y}}}
\newcommand{\vZ}{{\mathbf{Z}}}

\newcommand{\vlam}{{\bm{\lambda}}}
\newcommand{\vtheta}{{\bm{\theta}}}
\newcommand{\veta}{{\bm{\eta}}}
\newcommand{\vell}{{\bm{\ell}}}
\newcommand{\vxi}{{\bm{\xi}}}
\newcommand{\vom}{\boldsymbol{\omega}}
\newcommand{\om}{{\omega}}
\newcommand{\tbit}[1]{\textbf{\textit{#1}}}
\newcommand{\trs}{{\top}}

%% macros for sets
\newcommand{\cA}{{\mathcal{A}}}
\newcommand{\cB}{{\mathcal{B}}}
\newcommand{\cC}{{\mathcal{C}}}
\newcommand{\cD}{{\mathcal{D}}}
\newcommand{\cE}{{\mathcal{E}}}
\newcommand{\cF}{{\mathcal{F}}}
\newcommand{\cG}{{\mathcal{G}}}
\newcommand{\cH}{{\mathcal{H}}}
\newcommand{\cI}{{\mathcal{I}}}
\newcommand{\cJ}{{\mathcal{J}}}
\newcommand{\cK}{{\mathcal{K}}}
\newcommand{\cL}{{\mathcal{L}}}
\newcommand{\cM}{{\mathcal{M}}}
\newcommand{\cN}{{\mathcal{N}}}
\newcommand{\cO}{{\mathcal{O}}}
\newcommand{\cP}{{\mathcal{P}}}
\newcommand{\cQ}{{\mathcal{Q}}}
\newcommand{\cR}{{\mathcal{R}}}
\newcommand{\cS}{{\mathcal{S}}}
\newcommand{\cT}{{\mathcal{T}}}
\newcommand{\cU}{{\mathcal{U}}}
\newcommand{\cV}{{\mathcal{V}}}
\newcommand{\cW}{{\mathcal{W}}}
\newcommand{\cX}{{\mathcal{X}}}
\newcommand{\cY}{{\mathcal{Y}}}
\newcommand{\cZ}{{\mathcal{Z}}}



%
\newcommand{\vareps}{\varepsilon}

%% macros for the real and imaginary parts
\newcommand{\ri}{{\mathrm{i}}}
\newcommand{\rr}{{\mathrm{r}}}

%% macros for math notions and operators
\newcommand{\EE}{\mathbb{E}} % expectation
\newcommand{\RR}{\mathbb{R}} % real
\newcommand{\CC}{\mathbb{C}} % complex
\newcommand{\ZZ}{\mathbb{Z}} % integer
\renewcommand{\SS}{{\mathbb{S}}} % symmetric matrix
\newcommand{\SSp}{\mathbb{S}_{+}} % symmetric positive semi-definite matrix
\newcommand{\SSpp}{\mathbb{S}_{++}} % symmetric positive definite matrix
\newcommand{\sign}{\mathrm{sign}} % sign function
\newcommand{\vzero}{\mathbf{0}} % 0 vector
\newcommand{\vone}{{\mathbf{1}}} % 1 vector
\newcommand{\grad}{{\nabla}}    % gradient
\newcommand{\dist}{\mathrm{dist}}    % distance
\newcommand{\op}{{\mathrm{op}}} % subscript for operator norm
\newcommand{\opt}{{\mathrm{opt}}} % subscript for optimal solution
%\newcommand{\supp}{{\mathrm{supp}}} % support
\newcommand{\Prob}{{\mathrm{Prob}}} % probability
\newcommand{\prox}{{\mathbf{prox}}} % proximal map
\newcommand{\Diag}{{\mathrm{Diag}}} % vector -> diagonal matrix
\newcommand{\diag}{{\mathrm{diag}}} % matrix diagonal -> vector
\newcommand{\dom}{{\mathrm{dom}}} % domain
\newcommand{\rank}{\textnormal{rank}}

\newcommand{\tr}{{\mathrm{tr}}} % trace
\newcommand{\TV}{{\mathrm{TV}}} % total variation
\newcommand{\Proj}{{\mathrm{Proj}}} % projection
\newcommand{\Null}{{\mathrm{Null}}} % null space
\newcommand{\Dim}{{\mathrm{dim}}} % dimension
\newcommand{\conv}{{\mathrm{conv}}} % convex hull
\newcommand{\clos}{{\mathrm{cl}}} % closure
\newcommand{\inte}{{\mathrm{int}}} % interior
\newcommand{\etal}{{\textit{et al.}}}
\newcommand{\conj}{{\mathrm{conj}}} % conjugate
\newcommand{\vvec}{{\mathrm{vec}}}
\newcommand{\fold}{{\mathbf{fold}}} % fold into a tensor
\newcommand{\unfold}{{\mathbf{unfold}}} % unfold a tensor
\newcommand{\fit}{{\mathrm{fit}}} % data fitting
\newcommand{\obj}{{\mathrm{obj}}} % data fitting
\newcommand{\round}{{\mathrm{round}}}
\newcommand{\epi}{\mathrm{epi}} %epigraph
\newcommand{\hyp}{\mathrm{hyp}} %hypograph

% rounding number
\newcommand{\err}{{\mathrm{err}}}
\newcommand{\ST}{\mbox{ subject to }}
\newcommand{\st}{\mbox{ s.t. }}

\newcommand{\ip}[2]{\langle #1 , #2 \rangle}
\newcommand{\by}{{\bf y}}
\newcommand{\bxs}{{\bf x}_{\epsilon,\lambda,q}}
\newcommand{\od}{\frac{d}{dt}}
\newcommand{\pd}{{\partial }}
\newcommand{\rankk}{{\hbox{rank}}}




\newcommand{\prev}{{\mathrm{prev}}} % previous iteration

\DeclareMathOperator{\shrink}{shrink} % shrinkage
\DeclareMathOperator{\hardthr}{hardthr} % hard thresholding
\DeclareMathOperator*{\argmin}{arg\,min} % argmin
\DeclareMathOperator*{\argmax}{arg\,max} % argmax

\DeclareMathOperator*{\Min}{minimize}
\DeclareMathOperator*{\Max}{maximize}



%% macros for environments math equations

\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}

\newcommand{\bdm}{\begin{displaymath}}
\newcommand{\edm}{\end{displaymath}}

\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}

\newcommand{\bfl}{\begin{flushleft}}
\newcommand{\efl}{\end{flushleft}}

\newcommand{\bt}{\begin{tabbing}}
\newcommand{\et}{\end{tabbing}}

\newcommand{\beqn}{\begin{eqnarray}}
\newcommand{\eeqn}{\end{eqnarray}}

\newcommand{\beqs}{\begin{align*}} % no equation numbers
\newcommand{\eeqs}{\end{align*}}  % no equation numbers

%% macros for theorem-like environments

\newtheorem{theorem}{Theorem}[section]
%\newtheorem{acknowledgement}{Acknowledgement}[section]
%\newtheorem{axiom}{Axiom}[section]
%\newtheorem{algorithm}{Algorithm}[section]
%\newtheorem{case}{Case}[section]
\newtheorem{claim}{Claim}[section]
%\newtheorem{conclusion}{Conclusion}[section]
%\newtheorem{condition}{Condition}[section]
%\newtheorem{conjecture}{Conjecture}[section]
\newtheorem{corollary}{Corollary}[section]
%\newtheorem{criterion}{Criterion}[section]
\newtheorem{defn}{Definition}[section]
\newtheorem{example}{Example}[section]
%\newtheorem{exercise}{Exercise}[section]
\newtheorem{lemma}{Lemma}[section]
%\newtheorem{notation}{Notation}[section]
%\newtheorem{problem}{Problem}[section]
\newtheorem{prop}{Proposition}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{assumption}{Assumption}
%\newtheorem{solution}{Solution}[section]
%\newtheorem{summary}{Summary}[section]



\newcommand{\hvx}{{\hat{\vx}}}

    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Mechanisms of Attention \& Transformers}
\author{Duke Kwon}
    
    
    
    
    

    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        \ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle

\textit{Draft 1, 5/26/24}

\textbf{Recommended Background:}\\
Linear algebra, Basic machine learning theory (loss, functional approximation, generalization), multilayer perceptrons/neural networks.

\textbf{Key Takeaways:}\\
Mathematical intuition of the attention mechanism and the transformer architecture, in an informal, interpretable way.

\textbf{Quick Intro:}\\
Generative AI and LLMs have become the next big craze, especially among people with a very limited understanding of how these models actually work -- however, that's another topic on general ignorance and lack of critical thinking in this world. From an ML perspective, the mathematical fundamentals remain the same, as all these models are modeled off of this mathematical intuition.

Not sure how attention and transformers are taught nowadays, but my mental image comes from a perspective of word embeddings. \textit{(Primarily influenced from one of my past professors Dr. Mohammad Zaki, and my work as a research data scientist working on topic models).}

\textbf{Preliminaries:}\\
Perhaps the most important step to do any sort of ML work is to be able to mathematically model the problem effectively. If you're unfamiliar with the NLP space, we need to somehow numerically represent words and sentences to actually be used as data. The simple approach would be to one-hot encode a vocabulary to use as the data itself, i.e., represent each word as a standard basis vector in a unique dimension. However, this obviously doesn't encode a lot of the important ties and information between words.

This was the motivation to a popular word embedding algorithm from about 2013, Word2Vec. The algorithm tries to learning vector representations of an entire vocabulary, with "semantic similarity" embedded into the space by using a distance or similarity measure between the vectors. I believe the approach used the autoencoder-esque model, which can be thought of as a feed forward neural network doing some nonlinear compression by an encoder to decoder approach, but if it wasn't, ultimately some feed forward network is chopped at the end (prediction/softmax layer). This layer at the end defines a high dimensional distribution of word vectors, with numerically close (cosine similarity) vectors are considered "semantically similar". This is effectively done by training the model to predict the word given the context, and the context given a word (the paper calls these two approaches the Continuous Bag of Words model, CBOW, and the Skip-Gram model, respectively).

\textbf{Minutiae about Word2Vec:} 
I don't really like having blog posts linking to other blog posts unless they're worthwhile topics, but if there's interest, I can talk more about the details of Word2Vec.

\textbf{Motivation:}\\

Word2Vec is a static model in the sense that there is only one vector representation of each word, learned/trained off the context. Certainly we can train the model consistently to learn new contexts to account for data shift, but there will still be scenarios where words can have multiple meanings and be semantically similar/distant depending on the context. Consider the word \textit{bank}, which can be used in a variety of contexts: \textit{the river bank, banking a basketball, a financial bank}. The dimensionality of the vector space is likely to be limited to learn all the possible word-to-word interactions, and thus if these varietal contexts are equally distributed in the data, the model will have to learn a vector space where the \textit{bank} vector is equidistant from \textit{river, basketball, financial} (assuming these are contextually unrelated). This motivates being able to learn some dynamic, \textit{contextual} representation of word vectors, where we \textit{pay attention} to the context.

\textbf{Attention Mechanism:}\\

Attention is just a new term to coin the well used mathematical idea of averaging in the context of word vectors (think statistical expectation and weighing by probabilities, or along the lines of adaboost if you're familiar). 

\textit{(I believe the initial idea was introduced in the RNNSearch paper, where they learned an encoder-decoder model with a bidirectional RNN (think of an RNN learning sequential dependencies not only from the right, but also from the left). They use an encoder-decoder architecture for a translation task, where basically the encoder encodes 1-hot vectors representing words to a shared space to the decoder, where the decoder than transforms the words to corresponding translated words. They used a feedforward network (nonlinear) to learn attention weights, depending on the current context vector (hidden state), the previous word guessed, and the bidirectional hidden states concatenated together (previous hidden state, and the future hidden state from the reverse direction). The outputs I believe were then softmaxed to produce a valid probability distribution, and be used as the averaging weights to the next context vector)}

In the paper introducing transformers (Attention Is All You Need), the idea remains similar: weigh a vector representation by some similarity measure on the context. First, here's a high level overview: I'll talk about the input, the transformations, and the output of what we call a self-attention block. 

All parameters are user defined and not set in stone unless specified otherwise.
The input to the self-attention is pretty standard to NLP: a block of token vectors $\vx_i \in \RR^{d_{model}}$ (paper uses 512), with a block length of $L$. A token is some split component of a word via a preprocessing step, tokenization. Given that we have control of how we want to preprocess our data, tokenization takes words and often splits them into subwords with some base meaning. For example, we can take the word "prejudice" and tokenize it into "pre" and "judice". A block is just a user defined parameter designating the length of the context for a single token. For example, it could be the average or max length of the amount of subwords for a sentence in your corpus. 

These inputs are projected (linearly) into 3 different vector spaces: Key, Query, and Value $\in \RR^{64}$. So for each $\vx_i$ in the block, $\vW_k\vx_i \mapsto \vq_i, \vW_q\vx_i \mapsto \vk_i, \vW_v\vx_i \mapsto \vv_i$, where $\vW_k, \vW_q \in \RR^{d_k \times d_{model}}, \vW_v \in \RR^{d_v \times d_{model}}$. 

The idea behind this is similar to what Word2Vec proposes: to learn some latent space where some distance or numerical similarity measure corresponds to semantic similarity. The key and query vectors function as the token representatives in this semantic space, where they use the dot-product as a measure of similarity. The query $\vq_i$ can be thought of as the main context word vector (think about a block being a sliding window surrounding a main context word in a sentence, and we do this for each word), which we want to measure the similarity to the key vectors corresponding to the context (block). 

So we do $L$ dot products for each $\vq_i$, which corresponds to a matrix product $QK^\trs$, $Q,W \in \RR^{L\times d_k}$, where $\vq_i$ corresponds to row $i$ of matrix $Q$, and column $j$ corresponds to $\vk_j$. This results in an $L \times L$ matrix, where a row corresponds to the current context word $\vq_i$ similarity against each $\vk_j$ across the columns. For numerical stability, they scale down the values by $\sqrt{d_k}$, and then apply a row-wise softmax to normalize these similarity weights to a valid probability distribution. What we end up with is called the attention matrix. 
$$A = \mbox{softmax}_{row-wise}\left(\frac{QK^\trs}{\sqrt{d_k}}\right)$$.

If linear algebra isn't your strong suite, basically for each query vector $\vq_i$, we evaluated how much the surrounding context words (represented as key vectors $\vk_j$) contextually contribute or have some semantic similarity to the main context word (represented by a query vector $\vq_i$), a total of $L$ similarity measurements (includes the measurement with its own key vector $\vk_i$). These pre-softmax attention values then are condensed to be within $[0, 1]$ via row-wise softmax (row-wise corresponding to each query in the block), so that we have a fractional/probabilitistic representation of the strength of each context.

For each row of attention values corresponding to a query, we then compute a weighted sum of the block's value vectors $\vk_j$, i.e., $\vv_i' = \sum_{j=1}^{L}\alpha_{ij}\vv_j$, weighed by the corresponding attention values. In matrix form, this give us:
$$V' = Attention(Q, K, V) = \mbox{softmax}_{row-wise}\left(\frac{QK^\trs}{\sqrt{d_k}}\right)V = AV$$
Where $V \in \RR^{L \times d_v}$ (so rows are value vectors $\vv_j$).


So each query vector has been "contextualized" by assigning more weight to key vectors in the context that it's close to. The distinction to Word2Vec is apparent at this step: whereas Word2Vec generates a space to do similarity measurements on the "value vectors"/vectors themselves, Attention does the similarity measure in a separate key and query space, which they then weigh these similarity measures to the actual value vectors. We can expect to have a different contextualized value vector $\vv_i'$ for a different tokens in the context block (for the same main word).

\textit{(In the original RNNSearch paper, they use what's called "Additive Attention", where the attention values are computed from a learned feedforward neural network dependent on the bidirectional hidden states. Here we use "multiplicative" or dot-product attention).}


Finally, the set of $L$ value vectors are then projected back up to the dimensionality of $d_{model}$, $V'W_o \in \RR^{L \times d_{model}}, W_o \in \RR^{\vd_v \times d_{model}}$, which effectively is the output of the attention head for the single case. 

\textit{(The reason it's called *self* attention is due to the query and key vectors coming from the same context. There are instances of attention where we can pass key and query vectors from another domain (e.g., in translation, representing english words, encoding 1-hot to english) to the attention module in another domain (value vectors corresponding to french words)).}

Given that we understand attention for a "single" head, Multi-Headed Self-Attention (MHSA) consists of multiple attention modules within itself (the idea is similar to how CNNs have multiple masks/kernels to learn a surface). Words often have multiple and important but nuanced patterns of context. With only one attention head, we might only capture some information about the context dependencies of a word, thus  motivating multiple heads. With more attention heads, we can a variety of contexts that words can be in. The model basically learns multiple ($h$ heads) randomly initialized linear projection matrices for $Q, K, \& V$ in parallel. $$\mbox{head}_i = (QW_q^i, KW_k^i, VW_v^i)$$
This corresponds to $h$ different attention matrices for an input block. 

How does this affect the dimensionality with respect to the outputs? To account for this, they set $d_v = 64$, and $h = 8$, so that they can concatenate the value vectors/attention heads corresponding to different contexts $V_i'$, where $d_v * h = d_{model}$. Concatenating preserves the differences in the learned attention heads (compared to averaging, where subtle yet important outlier information can be lost). The final projection matrix $W_o$ now projects the final concatenated heads to $d_{model}, W_o \in \RR^{(h*d_v) \times d_{model}}$, similar to the single headed case.

So while Word2Vec creates "static" semantic vectors learned off of context, the attention mechanism learns dynamic semantic vectors depending on not only the previously learned context, but the current block context. We can notice that a single head of attention does $L^2$ dot-products which can be done in parallel efficiently, where the sequential order does not mathematically matter -- this is an issue that will be addressed by the positional encoding of the broader transformer architecture.


\textbf{Broader Transformer Architecture:}\\

The MHSA is the key feature of the transformer, but there are a few other details to complete the architecture. 


\textbf{1.) Residual Connections:}\\

Residual connections are an architectual design between (skip) layers in a neural network. They function as a simple to improve connectivity/information flow across the model. Basically, data is passed directly to the output of the next layer, on top of whatever was passed into the current layer. For example, suppose our MHSA module produces nothing worthwhile, maybe in the initial steps of training. With a residual connection layer, "residual" or remaining data is still passed to the next layer. This is usually a sum of the input to the output vectors in the next layer. Thus, we don't directly lose anything if MHSA fails to contribute effectively. Residual connections also help to improve issues with vanishing gradients for longer neural networks. Backpropagation does powers of matrices to get the interactions of the loss to specific weights via the chain rule, which amplifies the dominant eigenvalue $\lambda_1$ to either go to $\infty$ (exploding gradients) or 0. Residual connections provide additional data to be moved across the network to alleviate some of this.

\textit{From a numerical linear algebra perspective, this is similar to the power method/dominant eigenvalue/eigenvector methods. Let's consider a matrix $\vA \in \RR^{n\times n}$ with a dominant eigenvalue $\lambda_1$. If we take some random vector $\vx \in \RR^n$, with probability 1, $\vx$ can be represented as a non-zero combination of the eigenvectors of $\vA$, $\vx = \sum_{i=1}^{n}\lambda_i\vv_i, \lambda_i \neq 0, \forall i = 1, \dots, n$. Then $\vA^k\vx = \sum_{i=1}^{n}\lambda_i\vA^k\vv_i = \sum_{i=1}^{n}\lambda_i^k\vv_i$, where $\lambda_1^k$ becomes the dominating term. Notice how if $\lambda_i < 1$, $\lambda_i^k \rightarrow 0$, and if $\lambda_i > 1$, $\lambda_i^k \rightarrow \infty$, as $k \rightarrow \infty$. This will actually bring us to normalizing, which is next.}

\textbf{2.) Layer Normalization:}\\

Layer normalization is as it sounds -- normalizing the neuron values in a layer to be mathematically nice, with mean $\mu = 0$ and standard deviation $\sigma = 1$. This helps us keep the gradients and transformations across layers to remain within the same scale. Given that we tend to use one learning rate for all the weight updates, keeping the layers numerically consistent tends to improve the stability of the training procedure, getting to the optimal much quicker. Note that the residual layer is first added to the output of the feed fordward layer token-wise (element-wise) before normalizing. 

\textbf{3.) Feed Forward Network:}\\

The transformer integrates a standard feed forward neural network to the output (after layer normalization \& residual connections) of the MHSA. This FFN is implemented token-wise (element-wise).

\textbf{4.) Positional Encodings:}\\

Recall that attention computes context weight by dot products, which isn't positionally dependent and can be done in parallel. However, the positioning of a sentence can drastically affect its meaning -- it's an important piece of data that would be beneficial to learn. Positional encodings are introduced at the inputs of the transformer model, to encode sequential or positional information numerically by adding some trigonometric function values.

One way to think of the positional encoding is from a discrete/binary perspective. Think of adding a vector represented in binary for each token, to represent its position. 

\textbf{5.) Encoder-Decoder Architecture:}\\

Finally, the encoder-decoder architecture joins two separate components of MHSA+FFN w/ residual connections and layer normalization together. The encoder architecture is pretty much the "transformer" we described, however, the true "transformer" consists of this joint encoder-decoder architecture. The decoder is very similar to the encoder portion, except that the key and query values are passed from the outputs of the encoder self-attention (so the decoder attention heads are not fully "self"). Secondly, the output tokens are masked/hidden at each "timestep" or up to token $t$, to ensure the decoder only uses what it has predicted thus far, and the tokens it knows thus far. Just to make this whole idea more concrete, think of the encoder token block as an english sentence. We first contextualize them into a dynamic embedding space. In the decoder section, we want to take these embeddings and "translate", or rather pick a certain set of words in another other domain language, e.g., French (which will have the highest probability in this word distribution), or in the training step, learn to maximize the next word in the true label sentence in French.

\end{document}
